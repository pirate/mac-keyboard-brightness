#!/usr/bin/env python3
"""Stream Apple SPU accelerometer as MSIG1 float32 mono."""

from __future__ import annotations

import argparse
import math
import multiprocessing
from multiprocessing import shared_memory
import os
import signal
import struct
import sys
import time
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent
LIB_ROOT = REPO_ROOT / "lib"
for _p in (LIB_ROOT, REPO_ROOT):
    if str(_p) not in sys.path:
        sys.path.insert(0, str(_p))

from bootstrap import maybe_reexec_venv

maybe_reexec_venv(__file__)

NATIVE_RATE_HZ = 800.0


class LinearResampler:
    """Minimal streaming linear resampler without external deps."""

    def __init__(self, input_rate: float, output_rate: float) -> None:
        if input_rate <= 0 or output_rate <= 0:
            raise ValueError("sample rates must be > 0")
        self.step = float(input_rate) / float(output_rate)
        self.buf: list[float] = []
        self.pos = 0.0

    def process(self, samples: list[float]) -> list[float]:
        if samples:
            self.buf.extend(float(s) for s in samples)
        if len(self.buf) < 2:
            return []

        out: list[float] = []
        max_pos = len(self.buf) - 1
        while self.pos < max_pos:
            i = int(self.pos)
            frac = self.pos - i
            a = self.buf[i]
            b = self.buf[i + 1]
            out.append(a + (b - a) * frac)
            self.pos += self.step

        trim = int(self.pos)
        if trim > 0:
            self.buf = self.buf[trim:]
            self.pos -= trim
        return out


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Read Apple SPU accelerometer and write MSIG1 float32 mono to stdout."
    )
    parser.add_argument(
        "--rate",
        type=float,
        default=800.0,
        help="Target output sample rate in Hz (0 < rate <= 800).",
    )
    parser.add_argument(
        "--axis",
        choices=("x", "y", "z", "mag"),
        default="mag",
        help="Axis to output as mono signal (default: mag).",
    )
    parser.add_argument(
        "--raw",
        action="store_true",
        help="Emit raw float32 payload without MSIG1 header.",
    )
    return parser.parse_args()


def require_root() -> None:
    if os.geteuid() != 0:
        prog = Path(sys.argv[0]).name
        raise SystemExit(f"{prog}: requires root. Run with: sudo {sys.argv[0]}")


def extract_axis(samples: list[tuple[float, float, float]], axis: str) -> list[float]:
    if axis == "x":
        return [x for x, _, _ in samples]
    if axis == "y":
        return [y for _, y, _ in samples]
    if axis == "z":
        return [z for _, _, z in samples]
    return [math.sqrt(x * x + y * y + z * z) for x, y, z in samples]


def write_header(sample_rate: float) -> None:
    sys.stdout.buffer.write(f"MSIG1 {int(round(sample_rate))}\n".encode("ascii"))
    sys.stdout.buffer.flush()


def write_f32(samples: list[float]) -> None:
    if not samples:
        return
    sys.stdout.buffer.write(struct.pack("<%sf" % len(samples), *samples))


def main() -> int:
    args = parse_args()
    if args.rate <= 0 or args.rate > NATIVE_RATE_HZ:
        raise SystemExit("--rate must satisfy: 0 < rate <= 800")

    try:
        from spu_sensor import SHM_SIZE, sensor_worker, shm_read_new
    except Exception as exc:
        raise SystemExit(f"accelerometer dependencies unavailable: {exc}") from exc

    require_root()

    decimate = max(1, int(math.floor(NATIVE_RATE_HZ / float(args.rate))))
    worker_rate = NATIVE_RATE_HZ / float(decimate)
    resampler = (
        LinearResampler(worker_rate, float(args.rate))
        if abs(worker_rate - args.rate) > 1e-6
        else None
    )

    shm = shared_memory.SharedMemory(create=True, size=SHM_SIZE)
    for i in range(SHM_SIZE):
        shm.buf[i] = 0
    worker: multiprocessing.Process | None = None
    last_total = 0
    running = True

    if not args.raw:
        write_header(float(args.rate))

    def _stop(_sig: int, _frame: object) -> None:
        nonlocal running
        running = False

    signal.signal(signal.SIGINT, _stop)
    signal.signal(signal.SIGTERM, _stop)

    try:
        worker = multiprocessing.Process(
            target=sensor_worker,
            args=(shm.name, 0, decimate),
            daemon=True,
        )
        worker.start()

        while running:
            if worker.exitcode is not None:
                raise RuntimeError(f"sensor worker exited with code {worker.exitcode}")

            samples, last_total = shm_read_new(shm.buf, last_total)
            if not samples:
                time.sleep(0.001)
                continue

            mono = extract_axis(samples, args.axis)
            out = resampler.process(mono) if resampler is not None else mono
            if out:
                write_f32(out)
                sys.stdout.buffer.flush()

    except BrokenPipeError:
        pass
    except RuntimeError as exc:
        print(f"accelerometer: {exc}", file=sys.stderr)
        return 1
    finally:
        if worker is not None and worker.is_alive():
            worker.terminate()
            worker.join(timeout=1.0)
            if worker.is_alive():
                worker.kill()
                worker.join(timeout=1.0)
        shm.close()
        try:
            shm.unlink()
        except FileNotFoundError:
            pass

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
