#!/usr/bin/env python3
"""Drive display brightness from an incoming MSIG1 signal envelope."""

from __future__ import annotations

import argparse
import signal
import sys
import time
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Read MSIG1 mono signal and map envelope to display brightness."
    )
    parser.add_argument(
        "--send-hz",
        type=float,
        default=30.0,
        help="Maximum display brightness update rate in Hz.",
    )
    parser.add_argument(
        "--min-level",
        type=float,
        default=0.08,
        help="Minimum output brightness level (0..1).",
    )
    parser.add_argument(
        "--max-level",
        type=float,
        default=1.0,
        help="Maximum output brightness level (0..1).",
    )
    parser.add_argument(
        "--gain",
        type=float,
        default=1.0,
        help="Linear gain applied to adaptive envelope before clamping.",
    )
    parser.add_argument(
        "--no-restore",
        action="store_true",
        help="Do not restore the initial display brightness on exit.",
    )
    return parser.parse_args()


def clamp01(value: float) -> float:
    return max(0.0, min(1.0, float(value)))


def main() -> int:
    args = parse_args()
    if args.send_hz <= 0:
        raise SystemExit("--send-hz must be > 0")

    try:
        from toolkit.dsp import AdaptiveLevel
        from toolkit.hardware import DisplayBrightnessController
        from toolkit.signal_stream import FloatSignalReader, is_tty_stdin
    except Exception as exc:
        raise SystemExit(f"screen-brightness dependencies unavailable: {exc}") from exc

    if is_tty_stdin():
        raise SystemExit("screen-brightness expects an MSIG1 stream on stdin")

    lo = clamp01(args.min_level)
    hi = clamp01(args.max_level)
    if hi < lo:
        lo, hi = hi, lo

    controller = DisplayBrightnessController()
    if not controller.available:
        raise SystemExit("display brightness control is unavailable on this system")

    initial_level = controller.get()
    reader = FloatSignalReader.from_stdin()
    leveler = AdaptiveLevel()

    running = True
    send_dt = 1.0 / float(args.send_hz)
    dt = 1.0 / float(reader.sample_rate)
    clock = time.monotonic()
    next_send = clock
    last_sent = None

    def _stop(_sig: int, _frame: object) -> None:
        nonlocal running
        running = False

    signal.signal(signal.SIGINT, _stop)
    signal.signal(signal.SIGTERM, _stop)

    try:
        chunk_bytes = max(16, int(reader.sample_rate / max(1.0, args.send_hz)) * 4)
        for chunk in reader.iter_chunks(chunk_bytes=chunk_bytes):
            if not running:
                break
            for sample in chunk:
                env = leveler.update(float(sample), dt)
                env = clamp01(env * float(args.gain))
                target = lo + env * (hi - lo)
                clock += dt
                if clock >= next_send and (last_sent is None or abs(target - last_sent) >= 0.01):
                    if controller.set(target):
                        last_sent = target
                    next_send = clock + send_dt
    finally:
        if not args.no_restore and initial_level is not None:
            _ = controller.set(initial_level)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
