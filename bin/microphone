#!/usr/bin/env python3
"""Capture default microphone and stream MSIG1 float32 mono."""

from __future__ import annotations

import argparse
import queue
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Capture mono float32 from default microphone and write MSIG1 stream."
    )
    parser.add_argument(
        "--rate",
        type=float,
        default=None,
        help="Capture sample rate in Hz (default: input device default).",
    )
    parser.add_argument(
        "--block-size",
        type=int,
        default=512,
        help="Audio callback block size in frames.",
    )
    return parser.parse_args()


def resolve_input_rate(sd: object, requested: float | None) -> float:
    if requested is not None:
        if requested <= 0:
            raise SystemExit("--rate must be > 0")
        return float(requested)
    info = sd.query_devices(None, "input")
    rate = float(info.get("default_samplerate", 0.0) or 0.0)
    if rate <= 0:
        return 48000.0
    return rate


def main() -> int:
    args = parse_args()

    try:
        import numpy as np
    except Exception as exc:
        raise SystemExit(f"numpy is required: {exc}") from exc

    try:
        from toolkit.signal_stream import FloatSignalWriter
    except Exception as exc:
        raise SystemExit(f"microphone dependencies unavailable: {exc}") from exc

    try:
        import sounddevice as sd
    except Exception as exc:
        raise SystemExit(f"sounddevice is required: {exc}") from exc

    rate = resolve_input_rate(sd, args.rate)
    q: queue.Queue[np.ndarray] = queue.Queue(maxsize=32)
    writer = FloatSignalWriter.to_stdout(sample_rate=rate)

    def callback(indata: np.ndarray, frames: int, _time: object, _status: object) -> None:
        if frames <= 0:
            return
        mono = np.asarray(indata[:, 0], dtype=np.float32).copy()
        try:
            q.put_nowait(mono)
        except queue.Full:
            try:
                _ = q.get_nowait()
            except queue.Empty:
                pass
            try:
                q.put_nowait(mono)
            except queue.Full:
                pass

    try:
        with sd.InputStream(
            channels=1,
            samplerate=rate,
            dtype="float32",
            blocksize=max(1, int(args.block_size)),
            callback=callback,
        ):
            while True:
                chunk = q.get()
                writer.write(chunk)
                writer.flush()
    except KeyboardInterrupt:
        return 0
    except BrokenPipeError:
        return 0


if __name__ == "__main__":
    raise SystemExit(main())
