#!/usr/bin/env python3
"""Drive Mac fan speeds from an incoming MSIG1 signal."""

from __future__ import annotations

import argparse
import math
import signal
import sys
import time
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from toolkit.bootstrap import maybe_reexec_venv

maybe_reexec_venv(__file__)


class BeatFollower:
    """Beat-friendly envelope follower with baseline subtraction and AGC."""

    def __init__(
        self,
        sample_rate: float,
        *,
        attack_ms: float,
        release_ms: float,
        baseline_ms: float,
        decay_per_s: float,
        gain: float,
    ) -> None:
        self.fs = max(1.0, float(sample_rate))
        self.attack_s = max(1e-4, float(attack_ms) / 1000.0)
        self.release_s = max(1e-4, float(release_ms) / 1000.0)
        self.baseline_s = max(1e-3, float(baseline_ms) / 1000.0)
        self.decay_per_s = max(0.1, float(decay_per_s))
        self.gain = max(0.0, float(gain))

        self.fast_env = 0.0
        self.slow_env = 0.0
        self.agc_peak = 1e-6
        self.out = 0.0

    @staticmethod
    def _lpf(prev: float, x: float, dt: float, tau: float) -> float:
        a = math.exp(-max(0.0, dt) / max(1e-6, tau))
        return a * prev + (1.0 - a) * x

    def update(self, sample: float, dt: float) -> float:
        x = abs(float(sample))
        tau = self.attack_s if x > self.fast_env else self.release_s
        self.fast_env = self._lpf(self.fast_env, x, dt, tau)
        self.slow_env = self._lpf(self.slow_env, self.fast_env, dt, self.baseline_s)

        onset = max(0.0, self.fast_env - self.slow_env)

        if onset > self.agc_peak:
            self.agc_peak += 0.08 * (onset - self.agc_peak)
        else:
            self.agc_peak += 0.002 * (onset - self.agc_peak)

        norm = onset / max(1e-7, self.agc_peak)
        norm = max(0.0, min(1.0, norm * self.gain))

        decay = math.exp(-self.decay_per_s * max(0.0, dt))
        self.out = max(norm, self.out * decay)
        return self.out


def clamp01(value: float) -> float:
    return max(0.0, min(1.0, float(value)))


MAX_SEND_HZ = 4.0


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Read MSIG1 mono signal and modulate left/right fan speed."
    )
    parser.add_argument(
        "--send-hz",
        type=float,
        default=MAX_SEND_HZ,
        help=f"Maximum fan target update rate in Hz (capped at {MAX_SEND_HZ:.0f}).",
    )
    parser.add_argument(
        "--min-rpm",
        type=float,
        default=None,
        help="Lower RPM bound used for pulsing (auto from hardware by default).",
    )
    parser.add_argument(
        "--max-rpm",
        type=float,
        default=None,
        help="Upper RPM bound used for pulsing (auto from hardware by default).",
    )
    parser.add_argument(
        "--min-frac",
        type=float,
        default=0.0,
        help=(
            "Lower bound as fraction of hardware span (0..1) when --min-rpm is not set "
            "(default: 0.0)."
        ),
    )
    parser.add_argument(
        "--max-frac",
        type=float,
        default=1.0,
        help=(
            "Upper bound as fraction of hardware span (0..1) when --max-rpm is not set "
            "(default: 1.0)."
        ),
    )
    parser.add_argument(
        "--pulse-depth",
        type=float,
        default=0.2,
        help="Inactive side pulse ratio while alternating (0..1, default: 0.2).",
    )
    parser.set_defaults(couple=True)
    parser.add_argument(
        "--couple",
        dest="couple",
        action="store_true",
        help="Drive both fans identically (default).",
    )
    parser.add_argument(
        "--alternate",
        dest="couple",
        action="store_false",
        help="Alternate left/right pulses on detected beats.",
    )
    parser.add_argument(
        "--input-map",
        choices=("auto", "direct", "beat"),
        default="auto",
        help=(
            "How input samples map to fan target: auto=direct when coupled, beat when alternating "
            "(default: auto)."
        ),
    )
    parser.add_argument(
        "--beat-threshold",
        type=float,
        default=0.58,
        help="Envelope threshold (0..1) for beat-triggered side switching.",
    )
    parser.add_argument(
        "--beat-hold-ms",
        type=float,
        default=180.0,
        help="Minimum milliseconds between side switches.",
    )
    parser.add_argument(
        "--gain",
        type=float,
        default=1.4,
        help="Post-normalization gain (default: 1.4).",
    )
    parser.add_argument(
        "--attack-ms",
        type=float,
        default=15.0,
        help="Envelope attack time in ms (default: 15).",
    )
    parser.add_argument(
        "--release-ms",
        type=float,
        default=650.0,
        help="Envelope release time in ms (default: 650).",
    )
    parser.add_argument(
        "--baseline-ms",
        type=float,
        default=1200.0,
        help="Moving baseline time in ms (default: 1200).",
    )
    parser.add_argument(
        "--decay-per-s",
        type=float,
        default=2.0,
        help="Output decay constant per second (default: 2.0).",
    )
    parser.add_argument(
        "--no-restore",
        action="store_true",
        help="Do not restore automatic fan control on exit.",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Print live stats to stderr (input/send rates, env, left/right RPM).",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    if args.send_hz <= 0:
        raise SystemExit("--send-hz must be > 0")
    if args.send_hz > MAX_SEND_HZ:
        raise SystemExit(f"--send-hz must be <= {MAX_SEND_HZ:.0f} for fan safety")
    if args.attack_ms <= 0 or args.release_ms <= 0 or args.baseline_ms <= 0:
        raise SystemExit("--attack-ms, --release-ms, and --baseline-ms must be > 0")
    if args.beat_hold_ms < 0:
        raise SystemExit("--beat-hold-ms must be >= 0")

    try:
        from toolkit.hardware import FanSpeedController
        from toolkit.signal_stream import FloatSignalReader, StreamFormatError, is_tty_stdin
    except Exception as exc:
        raise SystemExit(f"fan-speed dependencies unavailable: {exc}") from exc

    if is_tty_stdin():
        raise SystemExit("fan-speed expects an MSIG1 stream on stdin")

    controller = FanSpeedController()
    if not controller.available:
        raise SystemExit(
            f"fan-speed control unavailable ({controller.diagnostic}; run as root on Apple Silicon)"
        )

    limits = controller.limits()
    if limits is None:
        raise SystemExit("fan-speed could not read fan RPM limits")
    (left_lo, left_hi), (right_lo, right_hi) = limits

    hardware_floor = max(left_lo, right_lo)
    hardware_ceil = min(left_hi, right_hi)
    if hardware_ceil < hardware_floor:
        hardware_floor, hardware_ceil = hardware_ceil, hardware_floor

    span = max(0.0, hardware_ceil - hardware_floor)
    floor_rpm = hardware_floor + clamp01(args.min_frac) * span
    ceil_rpm = hardware_floor + clamp01(args.max_frac) * span

    if args.min_rpm is not None:
        floor_rpm = float(args.min_rpm)
    if args.max_rpm is not None:
        ceil_rpm = float(args.max_rpm)

    floor_rpm = max(hardware_floor, min(hardware_ceil, floor_rpm))
    ceil_rpm = max(hardware_floor, min(hardware_ceil, ceil_rpm))
    if ceil_rpm < floor_rpm:
        floor_rpm, ceil_rpm = ceil_rpm, floor_rpm

    pulse_depth = clamp01(args.pulse_depth)
    beat_threshold = clamp01(args.beat_threshold)
    map_mode = args.input_map
    if map_mode == "auto":
        map_mode = "direct" if args.couple else "beat"

    initial = controller.get()

    try:
        reader = FloatSignalReader.from_stdin()
    except (EOFError, StreamFormatError):
        return 0

    follower = BeatFollower(
        sample_rate=float(reader.sample_rate),
        attack_ms=float(args.attack_ms),
        release_ms=float(args.release_ms),
        baseline_ms=float(args.baseline_ms),
        decay_per_s=float(args.decay_per_s),
        gain=float(args.gain),
    )

    running = True
    send_dt = 1.0 / float(args.send_hz)
    dt = 1.0 / float(reader.sample_rate)
    signal_clock = 0.0
    next_send_wall = time.monotonic()
    hold_s = max(0.0, float(args.beat_hold_ms) / 1000.0)

    active_side = 0
    gate_armed = True
    last_switch = -1e9

    sends = 0
    sample_count = 0
    last_debug = time.monotonic()
    last_env = 0.0
    last_target_l = floor_rpm
    last_target_r = floor_rpm

    def _stop(_sig: int, _frame: object) -> None:
        nonlocal running
        running = False

    signal.signal(signal.SIGINT, _stop)
    signal.signal(signal.SIGTERM, _stop)

    if args.debug:
        print(
            (
                f"[fan] limits left={left_lo:.0f}-{left_hi:.0f} right={right_lo:.0f}-{right_hi:.0f} "
                f"effective={floor_rpm:.0f}-{ceil_rpm:.0f}"
            ),
            file=sys.stderr,
            flush=True,
        )

    try:
        chunk_bytes = max(16, int(reader.sample_rate / max(1.0, args.send_hz)) * 4)
        for chunk in reader.iter_chunks(chunk_bytes=chunk_bytes):
            if not running:
                break
            for sample in chunk:
                sample_count += 1
                raw = float(sample)
                signal_clock += dt

                if map_mode == "direct":
                    env = clamp01((raw + 1.0) * 0.5)
                else:
                    env = follower.update(raw, dt)
                last_env = env

                if not args.couple:
                    if env < beat_threshold * 0.55:
                        gate_armed = True
                    if gate_armed and env >= beat_threshold and (signal_clock - last_switch) >= hold_s:
                        active_side = 1 - active_side
                        gate_armed = False
                        last_switch = signal_clock

                if args.couple:
                    left_env = env
                    right_env = env
                elif active_side == 0:
                    left_env = env
                    right_env = env * pulse_depth
                else:
                    left_env = env * pulse_depth
                    right_env = env

                span = max(0.0, ceil_rpm - floor_rpm)
                target_left = floor_rpm + left_env * span
                target_right = floor_rpm + right_env * span
                last_target_l = target_left
                last_target_r = target_right

            now = time.monotonic()
            if now >= next_send_wall:
                if not controller.set(last_target_l, last_target_r):
                    raise RuntimeError(
                        f"failed writing fan speed via backend ({controller.diagnostic})"
                    )
                sends += 1
                next_send_wall = now + send_dt

            if args.debug:
                now = time.monotonic()
                span = now - last_debug
                if span >= 1.0:
                    in_hz = sample_count / max(1e-6, span)
                    send_hz = sends / max(1e-6, span)
                    side = "L" if active_side == 0 else "R"
                    print(
                        (
                            f"[fan] backend={controller.backend} in_hz~{in_hz:.0f} "
                            f"send_hz~{send_hz:.1f} mode={map_mode} env={last_env:.3f} "
                            f"L={last_target_l:.0f} R={last_target_r:.0f} side={side}"
                        ),
                        file=sys.stderr,
                        flush=True,
                    )
                    sample_count = 0
                    sends = 0
                    last_debug = now
    except RuntimeError as exc:
        print(f"fan-speed: {exc}", file=sys.stderr)
        return 1
    finally:
        if not args.no_restore:
            if initial is not None:
                _ = controller.set(initial[0], initial[1])
            _ = controller.restore_auto()

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
