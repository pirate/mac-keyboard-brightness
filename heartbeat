#!/usr/bin/env python3
"""Estimate heartbeat BPM/confidence from a streamed mono signal."""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from toolkit.bootstrap import maybe_reexec_venv

maybe_reexec_venv(__file__)


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        description=(
            "Consume an MSIG1 float32 mono stream and emit periodic BPM estimates "
            "as JSON lines."
        )
    )
    p.add_argument(
        "--interval",
        type=float,
        default=1.0,
        help="Emit interval in stream seconds (default: 1.0).",
    )
    p.add_argument(
        "--window-seconds",
        type=float,
        default=10.0,
        help="Estimator history window (default: 10.0).",
    )
    p.add_argument(
        "--chunk-bytes",
        type=int,
        default=16384,
        help="Read size in bytes (default: 16384).",
    )
    p.add_argument(
        "--raw",
        action="store_true",
        help="Read raw float32 input instead of MSIG1 header.",
    )
    p.add_argument(
        "--rate",
        type=float,
        default=None,
        help="Input sample rate Hz (required with --raw).",
    )
    p.add_argument(
        "--emit-final",
        action="store_true",
        help="Emit one final estimate at EOF if the interval boundary was not hit.",
    )
    return p


def emit_line(
    *,
    stream_seconds: float,
    bpm: float | None,
    confidence: float,
    sample_rate: float,
    samples_seen: int,
) -> None:
    payload = {
        "t_sec": round(stream_seconds, 3),
        "samples": int(samples_seen),
        "sample_rate_hz": int(round(sample_rate)),
        "bpm": None if bpm is None else round(float(bpm), 2),
        "confidence": round(float(confidence), 3),
    }
    print(json.dumps(payload, separators=(",", ":")), flush=True)


def main() -> int:
    args = build_parser().parse_args()

    try:
        from toolkit.dsp import HeartbeatEstimator
        from toolkit.signal_stream import (
            FloatSignalReader,
            StreamFormatError,
            install_sigpipe_default,
        )
    except ModuleNotFoundError as exc:
        print(f"error: missing dependency: {exc}", file=sys.stderr)
        return 2

    install_sigpipe_default()

    if args.interval <= 0:
        print("error: --interval must be > 0", file=sys.stderr)
        return 2
    if args.window_seconds <= 0:
        print("error: --window-seconds must be > 0", file=sys.stderr)
        return 2
    if args.chunk_bytes < 4:
        print("error: --chunk-bytes must be >= 4", file=sys.stderr)
        return 2

    try:
        reader = FloatSignalReader.from_stdin(raw=args.raw, sample_rate=args.rate)
    except EOFError:
        return 0
    except StreamFormatError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 2

    estimator = HeartbeatEstimator(
        sample_rate=reader.sample_rate, window_seconds=args.window_seconds
    )
    emit_every = max(1, int(round(args.interval * reader.sample_rate)))
    next_emit = emit_every
    samples_seen = 0
    emitted = 0

    for chunk in reader.iter_chunks(chunk_bytes=args.chunk_bytes):
        estimator.add(chunk)
        samples_seen += int(chunk.size)

        while samples_seen >= next_emit:
            bpm, conf = estimator.estimate()
            emit_line(
                stream_seconds=next_emit / reader.sample_rate,
                bpm=bpm,
                confidence=conf,
                sample_rate=reader.sample_rate,
                samples_seen=next_emit,
            )
            emitted += 1
            next_emit += emit_every

    if args.emit_final and samples_seen > 0:
        last_boundary = (next_emit - emit_every) if emitted > 0 else 0
        if samples_seen > last_boundary:
            bpm, conf = estimator.estimate()
            emit_line(
                stream_seconds=samples_seen / reader.sample_rate,
                bpm=bpm,
                confidence=conf,
                sample_rate=reader.sample_rate,
                samples_seen=samples_seen,
            )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
